package com.forge.plugin.cache

import com.forge.actions.ActionId
import com.forge.actions.ActionNode
import com.forge.actions.ActionResult
import com.forge.actions.ActionType
import com.forge.task.Task
import com.forge.plugin.api.*
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.slf4j.LoggerFactory
import java.io.File
import java.nio.file.Files
import java.security.MessageDigest
import java.time.Instant

/**
 * Cache action plugin that provides caching capabilities
 */
class CacheActionPlugin : ActionPlugin {
    override val metadata = ActionPluginMetadata(
        id = "forge.cache",
        name = "Cache Plugin",
        version = "1.0.0",
        description = "Provides caching capabilities for tasks",
        author = "Forge Team",
        tags = listOf("cache", "performance")
    )
    
    private val logger = LoggerFactory.getLogger(CacheActionPlugin::class.java)
    private lateinit var config: CacheConfig
    private lateinit var cacheStorage: CacheStorage
    
    override fun initialize(config: Map<String, Any>) {
        this.config = CacheConfig.from(config)
        this.cacheStorage = createCacheStorage(this.config)
        logger.info("Cache plugin initialized with local cache: ${this.config.localCacheDir}")
    }
    
    override fun inject(
        task: Task,
        graph: MutableActionGraph,
        context: ExecutionContext
    ) {
        if (!config.enabled || !task.cache) {\n            return\n        }\n        \n        val taskId = task.id.value\n        \n        // Add hash computation action\n        val hashAction = ActionNode(\n            id = ActionId.generate(task.project, task.target, CacheActionType.COMPUTE_HASH),\n            type = CacheActionType.COMPUTE_HASH,\n            project = task.project,\n            target = task.target,\n            inputs = mapOf(\n                \"files\" to task.inputs,\n                \"env\" to task.configuration.env,\n                \"dependencies\" to task.dependencies.map { it.value }\n            ),\n            metadata = mapOf(\"taskId\" to taskId)\n        )\n        \n        // Add cache check action\n        val checkAction = ActionNode(\n            id = ActionId.generate(task.project, task.target, CacheActionType.CHECK_CACHE),\n            type = CacheActionType.CHECK_CACHE,\n            project = task.project,\n            target = task.target,\n            dependencies = setOf(hashAction.id),\n            metadata = mapOf(\"taskId\" to taskId)\n        )\n        \n        // Add cache restore action (conditional on cache hit)\n        val restoreAction = ActionNode(\n            id = ActionId.generate(task.project, task.target, CacheActionType.RESTORE_CACHE),\n            type = CacheActionType.RESTORE_CACHE,\n            project = task.project,\n            target = task.target,\n            dependencies = setOf(checkAction.id),\n            inputs = mapOf(\"outputs\" to task.outputs),\n            metadata = mapOf(\n                \"taskId\" to taskId,\n                \"condition\" to \"cache_hit\"\n            )\n        )\n        \n        // Add cache save action (after task execution)\n        val saveAction = ActionNode(\n            id = ActionId.generate(task.project, task.target, CacheActionType.SAVE_CACHE),\n            type = CacheActionType.SAVE_CACHE,\n            project = task.project,\n            target = task.target,\n            inputs = mapOf(\"outputs\" to task.outputs),\n            metadata = mapOf(\n                \"taskId\" to taskId,\n                \"condition\" to \"success\"\n            )\n        )\n        \n        // Insert actions into the graph\n        val taskActions = graph.getTaskActions(taskId)\n        if (taskActions.isNotEmpty()) {\n            val firstTaskAction = taskActions.first()\n            val lastTaskAction = taskActions.last()\n            \n            // Insert hash and check before task execution\n            graph.insertBefore(firstTaskAction.id.value, hashAction)\n            graph.insertBefore(firstTaskAction.id.value, checkAction)\n            graph.insertBefore(firstTaskAction.id.value, restoreAction)\n            \n            // Insert save after task execution\n            graph.insertAfter(lastTaskAction.id.value, saveAction)\n        } else {\n            // No existing task actions, just add them\n            graph.addNode(hashAction)\n            graph.addNode(checkAction)\n            graph.addNode(restoreAction)\n            graph.addNode(saveAction)\n        }\n    }\n    \n    override fun getActionHandlers(): Map<ActionType, ActionHandler> {\n        return mapOf(\n            CacheActionType.COMPUTE_HASH to ComputeHashHandler(cacheStorage),\n            CacheActionType.CHECK_CACHE to CheckCacheHandler(cacheStorage),\n            CacheActionType.RESTORE_CACHE to RestoreCacheHandler(cacheStorage),\n            CacheActionType.SAVE_CACHE to SaveCacheHandler(cacheStorage)\n        )\n    }\n    \n    override fun getConfigurationSchema(): Schema {\n        return Schema(\n            properties = mapOf(\n                \"enabled\" to PropertySchema(\n                    type = \"boolean\",\n                    description = \"Enable caching\",\n                    default = true\n                ),\n                \"localCacheDir\" to PropertySchema(\n                    type = \"string\",\n                    description = \"Local cache directory\",\n                    default = \"~/.forge/cache\"\n                ),\n                \"remoteCacheUrl\" to PropertySchema(\n                    type = \"string\",\n                    description = \"Remote cache URL (optional)\",\n                    default = null\n                ),\n                \"maxSize\" to PropertySchema(\n                    type = \"number\",\n                    description = \"Maximum cache size in MB\",\n                    default = 10240 // 10GB\n                )\n            ),\n            required = emptyList()\n        )\n    }\n    \n    override fun shutdown() {\n        cacheStorage.close()\n    }\n    \n    private fun createCacheStorage(config: CacheConfig): CacheStorage {\n        return LocalCacheStorage(config.localCacheDir)\n    }\n}\n\n/**\n * Cache-specific action types\n */\nobject CacheActionType {\n    val COMPUTE_HASH = ActionType.valueOf(\"COMPUTE_HASH\")\n    val CHECK_CACHE = ActionType.valueOf(\"CHECK_CACHE\")\n    val RESTORE_CACHE = ActionType.valueOf(\"RESTORE_CACHE\")\n    val SAVE_CACHE = ActionType.valueOf(\"SAVE_CACHE\")\n}\n\n/**\n * Compute hash action handler\n */\nclass ComputeHashHandler(\n    private val cacheStorage: CacheStorage\n) : ActionHandler {\n    \n    override suspend fun execute(\n        action: ActionNode,\n        context: ExecutionContext\n    ): ActionResult = withContext(Dispatchers.IO) {\n        try {\n            val files = action.inputs[\"files\"] as? List<String> ?: emptyList()\n            val env = action.inputs[\"env\"] as? Map<String, String> ?: emptyMap()\n            val dependencies = action.inputs[\"dependencies\"] as? List<String> ?: emptyList()\n            \n            val hash = computeHash(files, env, dependencies, context.workspaceRoot)\n            \n            context.store(\"${action.metadata[\"taskId\"]}.hash\", hash)\n            \n            ActionResult.Success(\n                outputs = mapOf(\"hash\" to hash),\n                duration = 0\n            )\n        } catch (e: Exception) {\n            ActionResult.Failed(\"Failed to compute hash: ${e.message}\", e)\n        }\n    }\n    \n    private fun computeHash(\n        files: List<String>,\n        env: Map<String, String>,\n        dependencies: List<String>,\n        workspaceRoot: String\n    ): String {\n        val digest = MessageDigest.getInstance(\"SHA-256\")\n        \n        // Hash file contents and metadata\n        files.forEach { pattern ->\n            hashFiles(pattern, workspaceRoot, digest)\n        }\n        \n        // Hash environment variables\n        env.toSortedMap().forEach { (key, value) ->\n            digest.update(\"$key=$value\".toByteArray())\n        }\n        \n        // Hash dependencies\n        dependencies.sorted().forEach { dep ->\n            digest.update(dep.toByteArray())\n        }\n        \n        return digest.digest().joinToString(\"\") { \"%02x\".format(it) }\n    }\n    \n    private fun hashFiles(pattern: String, workspaceRoot: String, digest: MessageDigest) {\n        val workspaceDir = File(workspaceRoot)\n        // Simple glob matching - in production, you'd use a proper glob library\n        workspaceDir.walkTopDown().forEach { file ->\n            if (file.isFile && file.name.matches(Regex(pattern.replace(\"*\", \".*\")))) {\n                digest.update(file.name.toByteArray())\n                digest.update(file.lastModified().toString().toByteArray())\n                digest.update(file.length().toString().toByteArray())\n            }\n        }\n    }\n}\n\n/**\n * Check cache action handler\n */\nclass CheckCacheHandler(\n    private val cacheStorage: CacheStorage\n) : ActionHandler {\n    \n    override suspend fun execute(\n        action: ActionNode,\n        context: ExecutionContext\n    ): ActionResult {\n        val taskId = action.metadata[\"taskId\"] as String\n        val hash = context.retrieve<String>(\"$taskId.hash\")\n            ?: return ActionResult.Failed(\"Hash not found for task: $taskId\")\n        \n        val cacheHit = cacheStorage.exists(hash)\n        context.store(\"$taskId.cache_hit\", cacheHit)\n        \n        return ActionResult.Success(\n            outputs = mapOf(\n                \"cache_hit\" to cacheHit,\n                \"cache_key\" to hash\n            )\n        )\n    }\n}\n\n/**\n * Restore cache action handler\n */\nclass RestoreCacheHandler(\n    private val cacheStorage: CacheStorage\n) : ActionHandler {\n    \n    override suspend fun execute(\n        action: ActionNode,\n        context: ExecutionContext\n    ): ActionResult = withContext(Dispatchers.IO) {\n        val taskId = action.metadata[\"taskId\"] as String\n        val cacheHit = context.retrieve<Boolean>(\"$taskId.cache_hit\") ?: false\n        \n        if (!cacheHit) {\n            return@withContext ActionResult.Skipped(\"No cache hit\")\n        }\n        \n        val hash = context.retrieve<String>(\"$taskId.hash\")\n            ?: return@withContext ActionResult.Failed(\"Hash not found\")\n        \n        try {\n            val outputs = action.inputs[\"outputs\"] as? List<String> ?: emptyList()\n            val restored = cacheStorage.restore(hash, outputs, context.workspaceRoot)\n            \n            ActionResult.CacheHit(\n                cacheKey = hash,\n                restoredFrom = \"local\"\n            )\n        } catch (e: Exception) {\n            ActionResult.Failed(\"Failed to restore cache: ${e.message}\", e)\n        }\n    }\n}\n\n/**\n * Save cache action handler\n */\nclass SaveCacheHandler(\n    private val cacheStorage: CacheStorage\n) : ActionHandler {\n    \n    override suspend fun execute(\n        action: ActionNode,\n        context: ExecutionContext\n    ): ActionResult = withContext(Dispatchers.IO) {\n        val taskId = action.metadata[\"taskId\"] as String\n        val hash = context.retrieve<String>(\"$taskId.hash\")\n            ?: return@withContext ActionResult.Failed(\"Hash not found\")\n        \n        try {\n            val outputs = action.inputs[\"outputs\"] as? List<String> ?: emptyList()\n            cacheStorage.save(hash, outputs, context.workspaceRoot)\n            \n            ActionResult.Success(\n                outputs = mapOf(\n                    \"cached\" to true,\n                    \"cache_key\" to hash\n                )\n            )\n        } catch (e: Exception) {\n            ActionResult.Failed(\"Failed to save cache: ${e.message}\", e)\n        }\n    }\n}\n\n/**\n * Cache storage interface\n */\ninterface CacheStorage {\n    fun exists(key: String): Boolean\n    fun restore(key: String, outputs: List<String>, workspaceRoot: String): Boolean\n    fun save(key: String, outputs: List<String>, workspaceRoot: String)\n    fun close()\n}\n\n/**\n * Local file-based cache storage\n */\nclass LocalCacheStorage(private val cacheDir: String) : CacheStorage {\n    private val cacheDirectory = File(cacheDir.replace(\"~\", System.getProperty(\"user.home\")))\n    \n    init {\n        cacheDirectory.mkdirs()\n    }\n    \n    override fun exists(key: String): Boolean {\n        return File(cacheDirectory, key).exists()\n    }\n    \n    override fun restore(key: String, outputs: List<String>, workspaceRoot: String): Boolean {\n        val cacheFile = File(cacheDirectory, key)\n        if (!cacheFile.exists()) return false\n        \n        // In a real implementation, you'd extract a tar/zip file\n        // For now, just create the output directories\n        outputs.forEach { output ->\n            val outputFile = File(workspaceRoot, output)\n            outputFile.parentFile?.mkdirs()\n        }\n        \n        return true\n    }\n    \n    override fun save(key: String, outputs: List<String>, workspaceRoot: String) {\n        val cacheFile = File(cacheDirectory, key)\n        \n        // In a real implementation, you'd create a tar/zip file\n        // For now, just touch the cache file\n        cacheFile.createNewFile()\n        cacheFile.writeText(Instant.now().toString())\n    }\n    \n    override fun close() {\n        // Nothing to close for local storage\n    }\n}\n\n/**\n * Cache plugin configuration\n */\ndata class CacheConfig(\n    val enabled: Boolean = true,\n    val localCacheDir: String = \"~/.forge/cache\",\n    val remoteCacheUrl: String? = null,\n    val maxSize: Long = 10240 * 1024 * 1024 // 10GB in bytes\n) {\n    companion object {\n        fun from(config: Map<String, Any>): CacheConfig {\n            return CacheConfig(\n                enabled = (config[\"enabled\"] as? Boolean) ?: true,\n                localCacheDir = (config[\"localCacheDir\"] as? String) ?: \"~/.forge/cache\",\n                remoteCacheUrl = config[\"remoteCacheUrl\"] as? String,\n                maxSize = (config[\"maxSize\"] as? Number)?.toLong() ?: (10240 * 1024 * 1024)\n            )\n        }\n    }\n}